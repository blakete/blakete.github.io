<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>My Living Dragon — FIXED</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'/%3E">
  <style>
    body { margin:0; background:#111; display:flex; justify-content:center; align-items:center; height:100vh; }
    canvas { border:4px solid #333; image-rendering:pixelated; width:512px; height:512px; }
  </style>
</head>
<body>
<canvas id="ca" width="512" height="512"></canvas>
<script>
// =============================================================
// 1. GL SETUP
// =============================================================
const canvas = document.getElementById('ca');
const gl = canvas.getContext('webgl2');
if (!gl) {
  alert('WebGL2 not supported');
  throw new Error('WebGL2 not supported');
}
console.log('MAX_DRAW_BUFFERS =', gl.getParameter(gl.MAX_DRAW_BUFFERS));

// Extensions for float render targets
const ext = gl.getExtension('EXT_color_buffer_float');
if (!ext) {
  alert('EXT_color_buffer_float not supported');
  throw new Error('EXT_color_buffer_float not supported');
}

const TEX_SIZE = 64;
const CHANNELS = 16; // 4 RGBA float textures

let stateTex = [], tempTex = [], deltaTex = [], perceiveTex = [];
let fbo = {}, prog = {};
let time = 0;

// Create and bind a VAO (WebGL2 requires one)
const vao = gl.createVertexArray();

// =============================================================
// 2. HELPERS
// =============================================================
function createFloatTex() {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, TEX_SIZE, TEX_SIZE, 0, gl.RGBA, gl.FLOAT, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
  return tex;
}

function compile(src, type) {
  const sh = gl.createShader(type);
  gl.shaderSource(sh, src);
  gl.compileShader(sh);
  if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
    const log = gl.getShaderInfoLog(sh);
    console.error(log, src);
    throw new Error('Shader compile error');
  }
  return sh;
}

function linkProgram(vsSrc, fsSrc) {
  const vs = compile(vsSrc, gl.VERTEX_SHADER);
  const fs = compile(fsSrc, gl.FRAGMENT_SHADER);
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(p));
    throw new Error('Program link error');
  }
  return p;
}

function drawQuad() {
  gl.bindVertexArray(vao);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

// =============================================================
// 3. SHADERS (split perception into 3 passes of 4 MRTs each)
// =============================================================
const vs = `#version 300 es
precision highp float;
in vec2 p;
out vec2 uv;
void main(){ gl_Position=vec4(p,0.0,1.0); uv=(p+1.0)/2.0; }`;

// --- Perception, pass A: self (4 render targets) ---
const perceiveSelfFS = `#version 300 es
precision highp float;
uniform sampler2D s0; uniform sampler2D s1; uniform sampler2D s2; uniform sampler2D s3;
in vec2 uv;
layout(location=0) out vec4 o0;
layout(location=1) out vec4 o1;
layout(location=2) out vec4 o2;
layout(location=3) out vec4 o3;

float fetchComp(int tid, int comp, vec2 c){
  vec4 t = (tid==0)? texture(s0,c) : (tid==1)? texture(s1,c) : (tid==2)? texture(s2,c) : texture(s3,c);
  return (comp==0)? t.x : (comp==1)? t.y : (comp==2)? t.z : t.w;
}

void main(){
  vec2 p = vec2(1.0/64.0);
  mat3 idn = mat3(0,0,0, 0,1,0, 0,0,0);

  vec4 self0=vec4(0), self1=vec4(0), self2=vec4(0), self3=vec4(0);

  for(int c=0;c<16;c++){
    int tid = c>>2; int comp = c & 3;
    float v=0.0;
    for(int i=-1;i<=1;i++) for(int j=-1;j<=1;j++){
      vec2 off = vec2(float(i),float(j))*p;
      float n = fetchComp(tid, comp, uv+off);
      v  += n * idn[i+1][j+1];
    }
    if(tid==0){ self0[comp]=v; }
    else if(tid==1){ self1[comp]=v; }
    else if(tid==2){ self2[comp]=v; }
    else { self3[comp]=v; }
  }
  o0=self0; o1=self1; o2=self2; o3=self3;
}`;

// --- Perception, pass B: dx (4 render targets) ---
const perceiveDxFS = `#version 300 es
precision highp float;
uniform sampler2D s0; uniform sampler2D s1; uniform sampler2D s2; uniform sampler2D s3;
in vec2 uv;
layout(location=0) out vec4 o0;
layout(location=1) out vec4 o1;
layout(location=2) out vec4 o2;
layout(location=3) out vec4 o3;

float fetchComp(int tid, int comp, vec2 c){
  vec4 t = (tid==0)? texture(s0,c) : (tid==1)? texture(s1,c) : (tid==2)? texture(s2,c) : texture(s3,c);
  return (comp==0)? t.x : (comp==1)? t.y : (comp==2)? t.z : t.w;
}

void main(){
  vec2 p = vec2(1.0/64.0);
  mat3 sx  = mat3(-1,0,1, -2,0,2, -1,0,1)/8.0;

  vec4 dx0=vec4(0), dx1=vec4(0), dx2=vec4(0), dx3=vec4(0);

  for(int c=0;c<16;c++){
    int tid = c>>2; int comp = c & 3;
    float gx=0.0;
    for(int i=-1;i<=1;i++) for(int j=-1;j<=1;j++){
      vec2 off = vec2(float(i),float(j))*p;
      float n = fetchComp(tid, comp, uv+off);
      gx += n * sx[i+1][j+1];
    }
    if(tid==0){ dx0[comp]=gx; }
    else if(tid==1){ dx1[comp]=gx; }
    else if(tid==2){ dx2[comp]=gx; }
    else { dx3[comp]=gx; }
  }
  o0=dx0; o1=dx1; o2=dx2; o3=dx3;
}`;

// --- Perception, pass C: dy (4 render targets) ---
const perceiveDyFS = `#version 300 es
precision highp float;
uniform sampler2D s0; uniform sampler2D s1; uniform sampler2D s2; uniform sampler2D s3;
in vec2 uv;
layout(location=0) out vec4 o0;
layout(location=1) out vec4 o1;
layout(location=2) out vec4 o2;
layout(location=3) out vec4 o3;

float fetchComp(int tid, int comp, vec2 c){
  vec4 t = (tid==0)? texture(s0,c) : (tid==1)? texture(s1,c) : (tid==2)? texture(s2,c) : texture(s3,c);
  return (comp==0)? t.x : (comp==1)? t.y : (comp==2)? t.z : t.w;
}

void main(){
  vec2 p = vec2(1.0/64.0);
  mat3 sy  = mat3( 1,2,1,  0,0,0, -1,-2,-1)/8.0;

  vec4 dy0=vec4(0), dy1=vec4(0), dy2=vec4(0), dy3=vec4(0);

  for(int c=0;c<16;c++){
    int tid = c>>2; int comp = c & 3;
    float gy=0.0;
    for(int i=-1;i<=1;i++) for(int j=-1;j<=1;j++){
      vec2 off = vec2(float(i),float(j))*p;
      float n = fetchComp(tid, comp, uv+off);
      gy += n * sy[i+1][j+1];
    }
    if(tid==0){ dy0[comp]=gy; }
    else if(tid==1){ dy1[comp]=gy; }
    else if(tid==2){ dy2[comp]=gy; }
    else { dy3[comp]=gy; }
  }
  o0=dy0; o1=dy1; o2=dy2; o3=dy3;
}`;

// --- Update: 48 -> 144 -> 16 (weights as RGBA8UI -> usampler2D) ---
const updateFS = `#version 300 es
precision highp float;
precision highp usampler2D;

uniform usampler2D w1; // (144 x 48)
uniform usampler2D b1; // (1 x 144)
uniform usampler2D w2; // (16 x 144)
uniform usampler2D b2; // (1 x 16)

uniform sampler2D p0; uniform sampler2D p1; uniform sampler2D p2; uniform sampler2D p3;
uniform sampler2D p4; uniform sampler2D p5; uniform sampler2D p6; uniform sampler2D p7;
uniform sampler2D p8; uniform sampler2D p9; uniform sampler2D p10; uniform sampler2D p11;

in vec2 uv;
layout(location=0) out vec4 d0;
layout(location=1) out vec4 d1;
layout(location=2) out vec4 d2;
layout(location=3) out vec4 d3;

float unpackFloat(uvec4 rgba){
  uint bits = (rgba.a<<24u) | (rgba.b<<16u) | (rgba.g<<8u) | rgba.r;
  return uintBitsToFloat(bits);
}

void main(){
  // Read all 12 perception maps once
  vec4 P[12];
  P[0]=texture(p0,uv); P[1]=texture(p1,uv); P[2]=texture(p2,uv); P[3]=texture(p3,uv);
  P[4]=texture(p4,uv); P[5]=texture(p5,uv); P[6]=texture(p6,uv); P[7]=texture(p7,uv);
  P[8]=texture(p8,uv); P[9]=texture(p9,uv); P[10]=texture(p10,uv); P[11]=texture(p11,uv);

  // ---- layer 1: 48 -> 144 ----
  float H[144];
  for(int row=0; row<144; row++){
    float sum = 0.0;
    for(int col=0; col<48; col++){
      // w1 is laid out with width=48, height=144
      vec2 tc = vec2((float(col)+0.5)/48.0, (float(row)+0.5)/144.0);
      float w = unpackFloat(texture(w1, tc));
      int pid = col >> 2; int comp = col & 3;
      float perc = P[pid][comp];
      sum += w * perc;
    }
    vec2 bc = vec2((float(row)+0.5)/144.0, 0.5);
    float bias = unpackFloat(texture(b1, bc));
    H[row] = max(0.0, sum + bias);
  }

  // ---- layer 2: 144 -> 16 ----
  float D[16];
  for(int row=0; row<16; row++){
    float sum = 0.0;
    for(int col=0; col<144; col++){
      vec2 tc = vec2((float(col)+0.5)/144.0, (float(row)+0.5)/16.0);
      float w = unpackFloat(texture(w2, tc));
      sum += w * H[col];
    }
    vec2 bc = vec2((float(row)+0.5)/16.0, 0.5);
    D[row] = sum + unpackFloat(texture(b2, bc));
  }

  d0 = vec4(D[0],D[1],D[2],D[3]);
  d1 = vec4(D[4],D[5],D[6],D[7]);
  d2 = vec4(D[8],D[9],D[10],D[11]);
  d3 = vec4(D[12],D[13],D[14],D[15]);
}`;

// --- Stochastic update (no sampler arrays) ---
const stochasticFS = `#version 300 es
precision highp float;
uniform sampler2D s0; uniform sampler2D s1; uniform sampler2D s2; uniform sampler2D s3;
uniform sampler2D d0; uniform sampler2D d1; uniform sampler2D d2; uniform sampler2D d3;
uniform float t;
in vec2 uv;
layout(location=0) out vec4 o0;
layout(location=1) out vec4 o1;
layout(location=2) out vec4 o2;
layout(location=3) out vec4 o3;
float rnd(vec2 v){ return fract(sin(dot(v,vec2(12.9898,78.233)))*43758.5453); }
void main(){
  float m = step(0.5, rnd(uv+t));
  o0 = texture(s0,uv) + texture(d0,uv)*m;
  o1 = texture(s1,uv) + texture(d1,uv)*m;
  o2 = texture(s2,uv) + texture(d2,uv)*m;
  o3 = texture(s3,uv) + texture(d3,uv)*m;
}`;

// --- Alive mask (no sampler arrays; fixed vec2 literal) ---
const aliveFS = `#version 300 es
precision highp float;
uniform sampler2D s0; uniform sampler2D s1; uniform sampler2D s2; uniform sampler2D s3;
in vec2 uv;
layout(location=0) out vec4 o0;
layout(location=1) out vec4 o1;
layout(location=2) out vec4 o2;
layout(location=3) out vec4 o3;
void main(){
  vec2 p = vec2(1.0/64.0); float aMax=0.0;
  for(int i=-1;i<=1;i++) for(int j=-1;j<=1;j++){
    aMax = max(aMax, texture(s0, uv + vec2(float(i),float(j))*p).a);
  }
  float mask = step(0.1, aMax);
  o0 = texture(s0,uv)*mask;
  o1 = texture(s1,uv)*mask;
  o2 = texture(s2,uv)*mask;
  o3 = texture(s3,uv)*mask;
}`;

// --- Render ---
const renderFS = `#version 300 es
precision highp float;
uniform sampler2D s0;
in vec2 uv;
out vec4 color;
void main(){
  vec4 c = texture(s0, uv);
  vec3 rgb = c.rgb;
  float a = clamp(c.a,0.0,1.0);
  color = vec4(clamp(1.0-a+rgb,0.0,1.0), 1.0);
}`;

// =============================================================
// 4. PROGRAMS
// =============================================================
prog.perceiveSelf = linkProgram(vs, perceiveSelfFS);
prog.perceiveDx   = linkProgram(vs, perceiveDxFS);
prog.perceiveDy   = linkProgram(vs, perceiveDyFS);
prog.update = linkProgram(vs, updateFS);
prog.stochastic = linkProgram(vs, stochasticFS);
prog.alive = linkProgram(vs, aliveFS);
prog.render = linkProgram(vs, renderFS);

// =============================================================
// 5. LOAD PNG WEIGHTS AS INTEGER TEXTURES (RGBA8UI)
// =============================================================
async function loadWeights() {
  const base = '/assets/images/nca_weights/';
  const names = ['w1','b1','w2','b2'];
  const tex = [];
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);

  for (let n of names) {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = base + n + '.png';
    await new Promise(r=>{ img.onload = ()=>r(); img.onerror = e=>{console.error('Failed to load', img.src); r();}; });

    // Draw into a temp canvas to get raw RGBA bytes (PNG is sRGB, we want raw 0..255)
    const c = document.createElement('canvas');
    c.width = img.width; c.height = img.height;
    const ctx = c.getContext('2d');
    ctx.drawImage(img,0,0);
    const { data } = ctx.getImageData(0,0,c.width,c.height);

    const t = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, t);
    gl.texImage2D(
      gl.TEXTURE_2D, 0, gl.RGBA8UI, c.width, c.height, 0,
      gl.RGBA_INTEGER, gl.UNSIGNED_BYTE, data
    );
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    tex.push(t);
  }
  return tex; // [w1,b1,w2,b2]
}

// =============================================================
// 6. SETUP TEXTURES + FBOs
// =============================================================
function setup() {
  // Create textures
  for (let i=0;i<4;i++) { stateTex[i]=createFloatTex(); tempTex[i]=createFloatTex(); deltaTex[i]=createFloatTex(); }
  for (let i=0;i<12;i++) perceiveTex[i]=createFloatTex();

  // FBOs
  fbo.perceive = gl.createFramebuffer();
  fbo.delta    = gl.createFramebuffer();
  fbo.temp     = gl.createFramebuffer();
  fbo.final    = gl.createFramebuffer();

  // Seed the world: prepare four separate layers
  const layer = [0,1,2,3].map(()=> new Float32Array(TEX_SIZE*TEX_SIZE*4));
  const centerIdx = (32 * TEX_SIZE + 32) * 4;
  // alpha (channel 3 of first texture)
  layer[0][centerIdx + 3] = 1.0;
  // set channels 4..15 to 1 at the center
  for (let ch=4; ch<16; ch++){
    const tid = (ch>>2); const comp = (ch & 3);
    layer[tid][centerIdx + comp] = 1.0;
  }
  for (let i=0;i<4;i++){
    gl.bindTexture(gl.TEXTURE_2D, stateTex[i]);
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, TEX_SIZE, TEX_SIZE, gl.RGBA, gl.FLOAT, layer[i]);
  }
}

// =============================================================
// 7. GEOMETRY (FULLSCREEN QUAD)
// =============================================================
const quad = gl.createBuffer();
const verts = new Float32Array([
  -1,-1,  1,-1,  -1,1,  1,1
]);

// Create VAO and attribute binding for all programs
function initQuadAttribs() {
  gl.bindVertexArray(vao);
  gl.bindBuffer(gl.ARRAY_BUFFER, quad);
  gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
  for (const p of Object.values(prog)){
    const loc = gl.getAttribLocation(p, 'p');
    if (loc >= 0) {
      gl.enableVertexAttribArray(loc);
      gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
    }
  }
  gl.bindVertexArray(null);
}

// =============================================================
// 8. MAIN LOOP
// =============================================================
let weights;
let last = 0;
async function run(){
  weights = await loadWeights();
  setup();
  initQuadAttribs();
  requestAnimationFrame(frame);
}

function bindDrawBuffers(n){
  gl.drawBuffers(new Array(n).fill(0).map((_,i)=> gl.COLOR_ATTACHMENT0 + i));
}

function frame(t){
  if (t-last < 1000/30) { requestAnimationFrame(frame); return; }
  last = t; time += 0.001;

  // 1) PERCEIVE — split into 3 passes of 4 outputs each
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.perceive);
  gl.viewport(0,0,TEX_SIZE,TEX_SIZE);
  gl.bindVertexArray(vao);

  // A) self
  gl.useProgram(prog.perceiveSelf);
  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, stateTex[0]); gl.uniform1i(gl.getUniformLocation(prog.perceiveSelf,'s0'),0);
  gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, stateTex[1]); gl.uniform1i(gl.getUniformLocation(prog.perceiveSelf,'s1'),1);
  gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, stateTex[2]); gl.uniform1i(gl.getUniformLocation(prog.perceiveSelf,'s2'),2);
  gl.activeTexture(gl.TEXTURE3); gl.bindTexture(gl.TEXTURE_2D, stateTex[3]); gl.uniform1i(gl.getUniformLocation(prog.perceiveSelf,'s3'),3);
  for (let i=0;i<4;i++) gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, perceiveTex[i], 0);
  bindDrawBuffers(4);
  drawQuad();

  // B) dx
  gl.useProgram(prog.perceiveDx);
  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, stateTex[0]); gl.uniform1i(gl.getUniformLocation(prog.perceiveDx,'s0'),0);
  gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, stateTex[1]); gl.uniform1i(gl.getUniformLocation(prog.perceiveDx,'s1'),1);
  gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, stateTex[2]); gl.uniform1i(gl.getUniformLocation(prog.perceiveDx,'s2'),2);
  gl.activeTexture(gl.TEXTURE3); gl.bindTexture(gl.TEXTURE_2D, stateTex[3]); gl.uniform1i(gl.getUniformLocation(prog.perceiveDx,'s3'),3);
  for (let i=0;i<4;i++) gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, perceiveTex[4+i], 0);
  bindDrawBuffers(4);
  drawQuad();

  // C) dy
  gl.useProgram(prog.perceiveDy);
  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, stateTex[0]); gl.uniform1i(gl.getUniformLocation(prog.perceiveDy,'s0'),0);
  gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, stateTex[1]); gl.uniform1i(gl.getUniformLocation(prog.perceiveDy,'s1'),1);
  gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, stateTex[2]); gl.uniform1i(gl.getUniformLocation(prog.perceiveDy,'s2'),2);
  gl.activeTexture(gl.TEXTURE3); gl.bindTexture(gl.TEXTURE_2D, stateTex[3]); gl.uniform1i(gl.getUniformLocation(prog.perceiveDy,'s3'),3);
  for (let i=0;i<4;i++) gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, perceiveTex[8+i], 0);
  bindDrawBuffers(4);
  drawQuad();

  // 2) UPDATE
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.delta);
  gl.useProgram(prog.update);
  gl.bindVertexArray(vao);
  // perception inputs
  for (let i=0;i<12;i++){
    gl.activeTexture(gl.TEXTURE0+i);
    gl.bindTexture(gl.TEXTURE_2D, perceiveTex[i]);
    gl.uniform1i(gl.getUniformLocation(prog.update,'p'+i), i);
  }
  // integer weight/bias textures
  gl.activeTexture(gl.TEXTURE12); gl.bindTexture(gl.TEXTURE_2D, weights[0]); gl.uniform1i(gl.getUniformLocation(prog.update,'w1'),12);
  gl.activeTexture(gl.TEXTURE13); gl.bindTexture(gl.TEXTURE_2D, weights[1]); gl.uniform1i(gl.getUniformLocation(prog.update,'b1'),13);
  gl.activeTexture(gl.TEXTURE14); gl.bindTexture(gl.TEXTURE_2D, weights[2]); gl.uniform1i(gl.getUniformLocation(prog.update,'w2'),14);
  gl.activeTexture(gl.TEXTURE15); gl.bindTexture(gl.TEXTURE_2D, weights[3]); gl.uniform1i(gl.getUniformLocation(prog.update,'b2'),15);
  for (let i=0;i<4;i++) gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, deltaTex[i], 0);
  bindDrawBuffers(4);
  drawQuad();

  // 3) STOCHASTIC
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.temp);
  gl.useProgram(prog.stochastic);
  gl.bindVertexArray(vao);
  gl.uniform1f(gl.getUniformLocation(prog.stochastic,'t'), time);
  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, stateTex[0]); gl.uniform1i(gl.getUniformLocation(prog.stochastic,'s0'),0);
  gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, stateTex[1]); gl.uniform1i(gl.getUniformLocation(prog.stochastic,'s1'),1);
  gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, stateTex[2]); gl.uniform1i(gl.getUniformLocation(prog.stochastic,'s2'),2);
  gl.activeTexture(gl.TEXTURE3); gl.bindTexture(gl.TEXTURE_2D, stateTex[3]); gl.uniform1i(gl.getUniformLocation(prog.stochastic,'s3'),3);
  gl.activeTexture(gl.TEXTURE4); gl.bindTexture(gl.TEXTURE_2D, deltaTex[0]); gl.uniform1i(gl.getUniformLocation(prog.stochastic,'d0'),4);
  gl.activeTexture(gl.TEXTURE5); gl.bindTexture(gl.TEXTURE_2D, deltaTex[1]); gl.uniform1i(gl.getUniformLocation(prog.stochastic,'d1'),5);
  gl.activeTexture(gl.TEXTURE6); gl.bindTexture(gl.TEXTURE_2D, deltaTex[2]); gl.uniform1i(gl.getUniformLocation(prog.stochastic,'d2'),6);
  gl.activeTexture(gl.TEXTURE7); gl.bindTexture(gl.TEXTURE_2D, deltaTex[3]); gl.uniform1i(gl.getUniformLocation(prog.stochastic,'d3'),7);
  for (let i=0;i<4;i++) gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, tempTex[i], 0);
  bindDrawBuffers(4);
  drawQuad();

  // 4) ALIVE
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.final);
  gl.useProgram(prog.alive);
  gl.bindVertexArray(vao);
  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, tempTex[0]); gl.uniform1i(gl.getUniformLocation(prog.alive,'s0'),0);
  gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, tempTex[1]); gl.uniform1i(gl.getUniformLocation(prog.alive,'s1'),1);
  gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, tempTex[2]); gl.uniform1i(gl.getUniformLocation(prog.alive,'s2'),2);
  gl.activeTexture(gl.TEXTURE3); gl.bindTexture(gl.TEXTURE_2D, tempTex[3]); gl.uniform1i(gl.getUniformLocation(prog.alive,'s3'),3);
  for (let i=0;i<4;i++) gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0+i, gl.TEXTURE_2D, stateTex[i], 0);
  bindDrawBuffers(4);
  drawQuad();

  // 5) RENDER
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.useProgram(prog.render);
  gl.bindVertexArray(vao);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, stateTex[0]);
  gl.uniform1i(gl.getUniformLocation(prog.render,'s0'),0);
  drawQuad();

  requestAnimationFrame(frame);
}

// =============================================================
// 9. DAMAGE INTERACTION
// =============================================================
const zeroPixel = new Float32Array([0,0,0,0]);
canvas.addEventListener('pointerdown', e=>{
  const r = canvas.getBoundingClientRect();
  const gx = Math.floor((e.clientX-r.left)/(r.width/64));
  const gy = Math.floor((e.clientY-r.top)/(r.height/64));
  const R = 5;
  for(let i=0;i<4;i++){
    gl.bindTexture(gl.TEXTURE_2D, stateTex[i]);
    for(let dx=-R;dx<=R;dx++) for(let dy=-R;dy<=R;dy++){
      if(dx*dx+dy*dy <= R*R){
        const x=gx+dx, y=gy+dy;
        if(x>=0&&x<64&&y>=0&&y<64)
          gl.texSubImage2D(gl.TEXTURE_2D,0,x,y,1,1,gl.RGBA,gl.FLOAT,zeroPixel);
      }
    }
  }
});

// =============================================================
// 10. QUAD SETUP & START
// =============================================================
(function setupQuad(){
  gl.bindVertexArray(vao);
  gl.bindBuffer(gl.ARRAY_BUFFER, quad);
  gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
  for(const p of Object.values(prog)){
    const loc = gl.getAttribLocation(p, 'p');
    if (loc >= 0) { gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0); }
  }
  gl.bindVertexArray(null);
})();

run();
</script>
</body>
</html>
